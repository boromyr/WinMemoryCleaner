name: Build and Release

on:
  push:
    branches:
      - main
      - develop

permissions:
  contents: write
  pull-requests: read

jobs:
  build:
    runs-on: windows-latest
    outputs:
      new_tag: ${{ steps.bump.outputs.new_tag }}

    steps:
      - name: Checkout repository code
        uses: actions/checkout@v3

      - name: Setup MSBuild environment
        uses: microsoft/setup-msbuild@v1

      - name: Bump minor version tag
        id: bump
        shell: pwsh
        run: |
          git fetch --tags
          $tags = git tag --sort=-creatordate | Where-Object { $_ -match '^[0-9]+\.[0-9]+$' }
          if (-not $tags) {
            $newTag = '1.0'
          } else {
            $parts = ($tags[0]).Split('.')
            $newTag = "{0}.{1}" -f $parts[0], ([int]$parts[1] + 1)
          }
          "new_tag=$newTag" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Restore NuGet packages
        shell: pwsh
        run: nuget restore src\WinMemoryCleaner.sln

      - name: Build solution with MSBuild
        shell: pwsh
        run: msbuild src\WinMemoryCleaner.sln /p:Configuration=Release /p:Platform="Any CPU"

      - name: Import signing certificate (main branch only)
        if: github.ref == 'refs/heads/main'
        shell: pwsh
        run: |
          echo "${{ secrets.SIGNING_CERT }}" | Out-File encoded.txt -Encoding ascii
          certutil -decode encoded.txt cert.pfx
          Remove-Item encoded.txt

      - name: Sign executable (main branch only)
        if: github.ref == 'refs/heads/main'
        shell: pwsh
        run: |
          $signtool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter signtool.exe |
            Where-Object { $_.FullName -match '\\x64\\' } |
            Select-Object -First 1 -ExpandProperty FullName
          if (-not $signtool) {
            $signtool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter signtool.exe |
              Where-Object { $_.FullName -match '\\x86\\' } |
              Select-Object -First 1 -ExpandProperty FullName
          }
          if (-not $signtool) {
            Write-Error "signtool.exe not found"
            exit 1
          }
          if (-not (Test-Path cert.pfx)) {
            Write-Error "cert.pfx not found!"
            exit 1
          }
          $exePath = Resolve-Path src\bin\Release\WinMemoryCleaner.exe
          & $signtool sign /f cert.pfx /p "${{ secrets.SIGNING_PASSWORD }}" `
            /tr http://timestamp.digicert.com /td sha256 /fd sha256 $exePath

      - name: Verify signature (main branch only)
        if: github.ref == 'refs/heads/main'
        shell: pwsh
        run: |
          $sigInfo = Get-AuthenticodeSignature -FilePath src\bin\Release\WinMemoryCleaner.exe
          if ($sigInfo.SignerCertificate -eq $null) {
            Write-Error "Executable is not signed!"
            exit 1
          }

      - name: Cleanup signing certificate (main branch only)
        if: github.ref == 'refs/heads/main'
        shell: pwsh
        run: Remove-Item cert.pfx

      - name: Create ZIP archive (main branch only)
        if: github.ref == 'refs/heads/main'
        shell: pwsh
        run: Compress-Archive -Path src\bin\Release\WinMemoryCleaner.exe -DestinationPath WinMemoryCleaner.zip

      - name: Upload build artifacts for release (main branch only)
        if: github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          name: built
          path: |
            src\bin\Release\WinMemoryCleaner.exe
            WinMemoryCleaner.zip

  release:
    needs: build
    runs-on: windows-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Checkout repository code
        uses: actions/checkout@v3

      - name: Download build artifacts from build job (main branch only)
        uses: actions/download-artifact@v4
        with:
          name: built
          path: release_artifacts

      - name: Create or reuse version tag (main branch only)
        shell: pwsh
        run: |
          $tag = "${{ needs.build.outputs.new_tag }}"
          git fetch --tags
          $tagExists = git tag -l $tag
          if (-not $tagExists) {
            git config user.name "github-actions"
            git config user.email "github-actions@github.com"
            git tag $tag
            git push origin $tag
          } else {
            Write-Host "Tag '$tag' already exists. Reusing..."
          }

      - name: Check if release already exists (main branch only)
        id: check_release
        shell: pwsh
        run: |
          $tag = "${{ needs.build.outputs.new_tag }}"
          $headers = @{ Authorization = "Bearer $env:GITHUB_TOKEN" }
          $uri = "https://api.github.com/repos/${{ github.repository }}/releases/tags/$tag"
          $response = Invoke-WebRequest -Uri $uri -Headers $headers -UseBasicParsing -ErrorAction SilentlyContinue
          if ($response.StatusCode -eq 200) {
            Write-Host "Release already exists for tag $tag. Skipping release."
            "skip=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          } else {
            "skip=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          }
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload release assets (main branch only)
        if: steps.check_release.outputs.skip == 'false'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.build.outputs.new_tag }}
          files: |
            release_artifacts/src/bin/Release/WinMemoryCleaner.exe
            release_artifacts/WinMemoryCleaner.zip
          draft: true
          generate_release_notes: true
